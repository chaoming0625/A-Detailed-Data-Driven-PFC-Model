from itertools import product

import numba
import numpy as np
from scipy.integrate import quad
from scipy.optimize import fmin
from scipy.optimize import fsolve

__all__ = [
  'setup_neuron_params',
  'setup_synapse_params',
]


neu_type_ratio = np.asarray([47, 1.55, 1.55, 1.3, 1.3, 2.6, 2.1,
                             38, 0.25, 0.25, 0.25, 0.25, 1.8, 1.8]) / 100
L23_names = ['PC', 'IN-L', 'IN-L-d', 'IN-CL', 'IN-CL-AC', 'IN-CC', 'IN-F']
L5_names = ['PC', 'IN-L', 'IN-L-d', 'IN-CL', 'IN-CL-AC', 'IN-CC', 'IN-F']


def setup_neuron_params(num_per_column, num_column):
  NTypes = np.ceil(num_per_column * neu_type_ratio)
  NTypesN = len(NTypes)
  N = int(round(np.sum(NTypes), 0))
  if N != num_per_column:
    print('WARNING: Neurons can not be distributed evenly across cell types. Number of '
          'generated neurons ({}) differs from specified number ({}).'
          '\n'.format(N, num_per_column))

  CellPar = np.zeros((10, NTypesN))
  # g_L
  CellPar[1] = [3.0751, 1.6902, 1.6902, 3.0014, 3.0014, 3.0751, 3.3869,
                2.2513, 1.6902, 1.6902, 3.0014, 3.0014, 2.2513, 3.3869]
  # E_L
  CellPar[2] = [1.9661, 1.0353, 1.0353, 1.4581, 1.4581, 1.9661, 1.0106,
                1.0196, 1.0353, 1.0353, 1.4581, 1.4581, 1.0196, 1.0106]
  # delta_T
  CellPar[3] = [3.5945, 2.9528, 2.9528, 3.0991, 3.0991, 3.5945, 3.8065,
                3.4415, 2.9528, 2.9528, 3.0991, 3.0991, 3.4415, 3.8065]
  # V_up
  CellPar[4] = [1.0309, 3.2163, 3.2163, 3.1517, 3.1517, 1.0309, 3.0269,
                1.5178, 3.2163, 3.2163, 3.1517, 3.1517, 1.5178, 3.0269]
  # tau_w
  CellPar[5] = [3.1428, 2.8230, 2.8230, 2.9335, 2.9335, 3.1428, 2.3911,
                1.0702, 2.8230, 2.8230, 2.9335, 2.9335, 1.0702, 2.3911]
  # a
  CellPar[6] = [4.4809, 1.0542, 1.0542, 1.0730, 1.0730, 4.4809, 4.1986,
                4.5650, 1.0542, 1.0542, 1.0730, 1.0730, 4.5650, 4.1986]
  # b
  CellPar[7] = [1.0189, 2.5959, 2.5959, 0.6931, 0.6931, 1.0189, 0.8080,
                1.1154, 2.5959, 2.5959, 0.6931, 0.6931, 1.1154, 0.8080]
  # V_r
  CellPar[8] = [5.0719, 4.1321, 4.1321, 1.9059, 1.9059, 5.0719, 3.0051,
                4.3414, 4.1321, 4.1321, 1.9059, 1.9059, 4.3414, 3.0051]
  # V_T
  CellPar[9] = [2.9010, 3.6925, 3.6925, 2.9462, 2.9462, 2.9010, 3.0701,
                3.3302, 3.6925, 3.6925, 2.9462, 2.9462, 3.3302, 3.0701]

  ParCov = np.asarray(
    [
      np.matrix([[1.0000, 0.1580, -0.5835, 0.4011, -0.0561, 0.0718, -0.2038, 0.2615, -0.2365],
                 [0.1580, 1.0000, 0.0141, -0.1272, -0.4327, 0.1778, -0.0902, -0.0329, -0.3778],
                 [-0.5835, 0.0141, 1.0000, -0.6295, -0.2949, -0.2008, 0.3164, -0.2615, -0.0536],
                 [0.4011, -0.1272, -0.6295, 1.0000, 0.6960, -0.2587, -0.0988, 0.6113, 0.5636],
                 [-0.0561, -0.4327, -0.2949, 0.6960, 1.0000, -0.3370, 0.2042, 0.3959, 0.8581],
                 [0.0718, 0.1778, -0.2008, -0.2587, -0.3370, 1.0000, -0.0634, -0.5202, -0.3829],
                 [-0.2038, -0.0902, 0.3164, -0.0988, 0.2042, -0.0634, 1.0000, 0.0559, 0.3322],
                 [0.2615, -0.0329, -0.2615, 0.6113, 0.3959, -0.5202, 0.0559, 1.0000, 0.3210],
                 [-0.2365, -0.3778, -0.0536, 0.5636, 0.8581, -0.3829, 0.3322, 0.3210, 1.0000]]),
      np.matrix([[1.0000, -0.2894, 0.0381, 0.0664, -0.2418, 0.2253, 0.2822, -0.2919, 0.0581],
                 [-0.2894, 1.0000, -0.2259, 0.4265, 0.1859, -0.6307, -0.0140, 0.4944, 0.2495],
                 [0.0381, -0.2259, 1.0000, -0.2855, 0.0724, 0.1199, -0.1487, -0.3773, 0.1881],
                 [0.0664, 0.4265, -0.2855, 1.0000, 0.2208, -0.3752, 0.0660, 0.3415, 0.7289],
                 [-0.2418, 0.1859, 0.0724, 0.2208, 1.0000, 0.1412, -0.2931, 0.1993, 0.4609],
                 [0.2253, -0.6307, 0.1199, -0.3752, 0.1412, 1.0000, -0.2855, -0.2046, -0.1974],
                 [0.2822, -0.0140, -0.1487, 0.0660, -0.2931, -0.2855, 1.0000, -0.1172, -0.0851],
                 [-0.2919, 0.4944, -0.3773, 0.3415, 0.1993, -0.2046, -0.1172, 1.0000, 0.0530],
                 [0.0581, 0.2495, 0.1881, 0.7289, 0.4609, -0.1974, -0.0851, 0.0530, 1.0000]]),
      np.matrix([[1.0000, -0.2894, 0.0381, 0.0664, -0.2418, 0.2253, 0.2822, -0.2919, 0.0581],
                 [-0.2894, 1.0000, -0.2259, 0.4265, 0.1859, -0.6307, -0.0140, 0.4944, 0.2495],
                 [0.0381, -0.2259, 1.0000, -0.2855, 0.0724, 0.1199, -0.1487, -0.3773, 0.1881],
                 [0.0664, 0.4265, -0.2855, 1.0000, 0.2208, -0.3752, 0.0660, 0.3415, 0.7289],
                 [-0.2418, 0.1859, 0.0724, 0.2208, 1.0000, 0.1412, -0.2931, 0.1993, 0.4609],
                 [0.2253, -0.6307, 0.1199, -0.3752, 0.1412, 1.0000, -0.2855, -0.2046, -0.1974],
                 [0.2822, -0.0140, -0.1487, 0.0660, -0.2931, -0.2855, 1.0000, -0.1172, -0.0851],
                 [-0.2919, 0.4944, -0.3773, 0.3415, 0.1993, -0.2046, -0.1172, 1.0000, 0.0530],
                 [0.0581, 0.2495, 0.1881, 0.7289, 0.4609, -0.1974, -0.0851, 0.0530, 1.0000]]),
      np.matrix([[1.0000, -0.2394, -0.6001, 0.3114, -0.2367, 0.5856, 0.2077, 0.0171, -0.4079],
                 [-0.2394, 1.0000, -0.1764, 0.4675, 0.1810, -0.4942, -0.4389, 0.6950, 0.0811],
                 [-0.6001, -0.1764, 1.0000, -0.6002, 0.2170, -0.0922, 0.2129, -0.3566, 0.4204],
                 [0.3114, 0.4675, -0.6002, 1.0000, 0.2597, -0.1039, -0.5507, 0.7230, 0.0775],
                 [-0.2367, 0.1810, 0.2170, 0.2597, 1.0000, 0.2159, -0.7123, 0.0193, 0.8494],
                 [0.5856, -0.4942, -0.0922, -0.1039, 0.2159, 1.0000, 0.0587, -0.4724, 0.0957],
                 [0.2077, -0.4389, 0.2129, -0.5507, -0.7123, 0.0587, 1.0000, -0.3395, -0.5780],
                 [0.0171, 0.6950, -0.3566, 0.7230, 0.0193, -0.4724, -0.3395, 1.0000, -0.1084],
                 [-0.4079, 0.0811, 0.4204, 0.0775, 0.8494, 0.0957, -0.5780, -0.1084, 1.0000]]),
      np.matrix([[1.0000, -0.2394, -0.6001, 0.3114, -0.2367, 0.5856, 0.2077, 0.0171, -0.4079],
                 [-0.2394, 1.0000, -0.1764, 0.4675, 0.1810, -0.4942, -0.4389, 0.6950, 0.0811],
                 [-0.6001, -0.1764, 1.0000, -0.6002, 0.2170, -0.0922, 0.2129, -0.3566, 0.4204],
                 [0.3114, 0.4675, -0.6002, 1.0000, 0.2597, -0.1039, -0.5507, 0.7230, 0.0775],
                 [-0.2367, 0.1810, 0.2170, 0.2597, 1.0000, 0.2159, -0.7123, 0.0193, 0.8494],
                 [0.5856, -0.4942, -0.0922, -0.1039, 0.2159, 1.0000, 0.0587, -0.4724, 0.0957],
                 [0.2077, -0.4389, 0.2129, -0.5507, -0.7123, 0.0587, 1.0000, -0.3395, -0.5780],
                 [0.0171, 0.6950, -0.3566, 0.7230, 0.0193, -0.4724, -0.3395, 1.0000, -0.1084],
                 [-0.4079, 0.0811, 0.4204, 0.0775, 0.8494, 0.0957, -0.5780, -0.1084, 1.0000]]),
      np.matrix([[1.0000, 0.1580, -0.5835, 0.4011, -0.0561, 0.0718, -0.2038, 0.2615, -0.2365],
                 [0.1580, 1.0000, 0.0141, -0.1272, -0.4327, 0.1778, -0.0902, -0.0329, -0.3778],
                 [-0.5835, 0.0141, 1.0000, -0.6295, -0.2949, -0.2008, 0.3164, -0.2615, -0.0536],
                 [0.4011, -0.1272, -0.6295, 1.0000, 0.6960, -0.2587, -0.0988, 0.6113, 0.5636],
                 [-0.0561, -0.4327, -0.2949, 0.6960, 1.0000, -0.3370, 0.2042, 0.3959, 0.8581],
                 [0.0718, 0.1778, -0.2008, -0.2587, -0.3370, 1.0000, -0.0634, -0.5202, -0.3829],
                 [-0.2038, -0.0902, 0.3164, -0.0988, 0.2042, -0.0634, 1.0000, 0.0559, 0.3322],
                 [0.2615, -0.0329, -0.2615, 0.6113, 0.3959, -0.5202, 0.0559, 1.0000, 0.3210],
                 [-0.2365, -0.3778, -0.0536, 0.5636, 0.8581, -0.3829, 0.3322, 0.3210, 1.0000]]),
      np.matrix([[1.0000, -0.1586, 0.1817, -0.0195, -0.0884, 0.0282, 0.0560, -0.1369, 0.0099],
                 [-0.1586, 1.0000, 0.0440, 0.1013, -0.2510, -0.0046, -0.1105, 0.0738, -0.1152],
                 [0.1817, 0.0440, 1.0000, -0.5118, 0.0414, 0.2570, 0.0932, 0.0961, 0.4938],
                 [-0.0195, 0.1013, -0.5118, 1.0000, 0.0480, -0.1155, -0.2463, -0.0754, 0.0204],
                 [-0.0884, -0.2510, 0.0414, 0.0480, 1.0000, 0.2577, -0.0581, 0.3152, 0.3151],
                 [0.0282, -0.0046, 0.2570, -0.1155, 0.2577, 1.0000, -0.1598, 0.4397, 0.1107],
                 [0.0560, -0.1105, 0.0932, -0.2463, -0.0581, -0.1598, 1.0000, -0.4617, 0.1872],
                 [-0.1369, 0.0738, 0.0961, -0.0754, 0.3152, 0.4397, -0.4617, 1.0000, -0.0114],
                 [0.0099, -0.1152, 0.4938, 0.0204, 0.3151, 0.1107, 0.1872, -0.0114, 1.0000]]),

      np.matrix([[1.0000, -0.2440, -0.2729, 0.2863, -0.0329, 0.2925, -0.0588, 0.3377, -0.1914],
                 [-0.2440, 1.0000, 0.0874, -0.1523, -0.2565, -0.1605, 0.0874, -0.2895, -0.2125],
                 [-0.2729, 0.0874, 1.0000, -0.6332, 0.2012, -0.0578, 0.0283, -0.1100, 0.3013],
                 [0.2863, -0.1523, -0.6332, 1.0000, 0.3140, 0.2152, -0.1084, 0.4114, 0.1732],
                 [-0.0329, -0.2565, 0.2012, 0.3140, 1.0000, 0.3184, -0.1923, 0.3761, 0.8433],
                 [0.2925, -0.1605, -0.0578, 0.2152, 0.3184, 1.0000, 0.1246, 0.4736, 0.2078],
                 [-0.0588, 0.0874, 0.0283, -0.1084, -0.1923, 0.1246, 1.0000, 0.0752, -0.1578],
                 [0.3377, -0.2895, -0.1100, 0.4114, 0.3761, 0.4736, 0.0752, 1.0000, 0.2114],
                 [-0.1914, -0.2125, 0.3013, 0.1732, 0.8433, 0.2078, -0.1578, 0.2114, 1.0000]]),
      np.matrix([[1.0000, -0.2894, 0.0381, 0.0664, -0.2418, 0.2253, 0.2822, -0.2919, 0.0581],
                 [-0.2894, 1.0000, -0.2259, 0.4265, 0.1859, -0.6307, -0.0140, 0.4944, 0.2495],
                 [0.0381, -0.2259, 1.0000, -0.2855, 0.0724, 0.1199, -0.1487, -0.3773, 0.1881],
                 [0.0664, 0.4265, -0.2855, 1.0000, 0.2208, -0.3752, 0.0660, 0.3415, 0.7289],
                 [-0.2418, 0.1859, 0.0724, 0.2208, 1.0000, 0.1412, -0.2931, 0.1993, 0.4609],
                 [0.2253, -0.6307, 0.1199, -0.3752, 0.1412, 1.0000, -0.2855, -0.2046, -0.1974],
                 [0.2822, -0.0140, -0.1487, 0.0660, -0.2931, -0.2855, 1.0000, -0.1172, -0.0851],
                 [-0.2919, 0.4944, -0.3773, 0.3415, 0.1993, -0.2046, -0.1172, 1.0000, 0.0530],
                 [0.0581, 0.2495, 0.1881, 0.7289, 0.4609, -0.1974, -0.0851, 0.0530, 1.0000]]),
      np.matrix([[1.0000, -0.2894, 0.0381, 0.0664, -0.2418, 0.2253, 0.2822, -0.2919, 0.0581],
                 [-0.2894, 1.0000, -0.2259, 0.4265, 0.1859, -0.6307, -0.0140, 0.4944, 0.2495],
                 [0.0381, -0.2259, 1.0000, -0.2855, 0.0724, 0.1199, -0.1487, -0.3773, 0.1881],
                 [0.0664, 0.4265, -0.2855, 1.0000, 0.2208, -0.3752, 0.0660, 0.3415, 0.7289],
                 [-0.2418, 0.1859, 0.0724, 0.2208, 1.0000, 0.1412, -0.2931, 0.1993, 0.4609],
                 [0.2253, -0.6307, 0.1199, -0.3752, 0.1412, 1.0000, -0.2855, -0.2046, -0.1974],
                 [0.2822, -0.0140, -0.1487, 0.0660, -0.2931, -0.2855, 1.0000, -0.1172, -0.0851],
                 [-0.2919, 0.4944, -0.3773, 0.3415, 0.1993, -0.2046, -0.1172, 1.0000, 0.0530],
                 [0.0581, 0.2495, 0.1881, 0.7289, 0.4609, -0.1974, -0.0851, 0.0530, 1.0000]]),
      np.matrix([[1.0000, -0.2394, -0.6001, 0.3114, -0.2367, 0.5856, 0.2077, 0.0171, -0.4079],
                 [-0.2394, 1.0000, -0.1764, 0.4675, 0.1810, -0.4942, -0.4389, 0.6950, 0.0811],
                 [-0.6001, -0.1764, 1.0000, -0.6002, 0.2170, -0.0922, 0.2129, -0.3566, 0.4204],
                 [0.3114, 0.4675, -0.6002, 1.0000, 0.2597, -0.1039, -0.5507, 0.7230, 0.0775],
                 [-0.2367, 0.1810, 0.2170, 0.2597, 1.0000, 0.2159, -0.7123, 0.0193, 0.8494],
                 [0.5856, -0.4942, -0.0922, -0.1039, 0.2159, 1.0000, 0.0587, -0.4724, 0.0957],
                 [0.2077, -0.4389, 0.2129, -0.5507, -0.7123, 0.0587, 1.0000, -0.3395, -0.5780],
                 [0.0171, 0.6950, -0.3566, 0.7230, 0.0193, -0.4724, -0.3395, 1.0000, -0.1084],
                 [-0.4079, 0.0811, 0.4204, 0.0775, 0.8494, 0.0957, -0.5780, -0.1084, 1.0000]]),
      np.matrix([[1.0000, -0.2394, -0.6001, 0.3114, -0.2367, 0.5856, 0.2077, 0.0171, -0.4079],
                 [-0.2394, 1.0000, -0.1764, 0.4675, 0.1810, -0.4942, -0.4389, 0.6950, 0.0811],
                 [-0.6001, -0.1764, 1.0000, -0.6002, 0.2170, -0.0922, 0.2129, -0.3566, 0.4204],
                 [0.3114, 0.4675, -0.6002, 1.0000, 0.2597, -0.1039, -0.5507, 0.7230, 0.0775],
                 [-0.2367, 0.1810, 0.2170, 0.2597, 1.0000, 0.2159, -0.7123, 0.0193, 0.8494],
                 [0.5856, -0.4942, -0.0922, -0.1039, 0.2159, 1.0000, 0.0587, -0.4724, 0.0957],
                 [0.2077, -0.4389, 0.2129, -0.5507, -0.7123, 0.0587, 1.0000, -0.3395, -0.5780],
                 [0.0171, 0.6950, -0.3566, 0.7230, 0.0193, -0.4724, -0.3395, 1.0000, -0.1084],
                 [-0.4079, 0.0811, 0.4204, 0.0775, 0.8494, 0.0957, -0.5780, -0.1084, 1.0000]]),
      np.matrix([[1.0000, -0.2440, -0.2729, 0.2863, -0.0329, 0.2925, -0.0588, 0.3377, -0.1914],
                 [-0.2440, 1.0000, 0.0874, -0.1523, -0.2565, -0.1605, 0.0874, -0.2895, -0.2125],
                 [-0.2729, 0.0874, 1.0000, -0.6332, 0.2012, -0.0578, 0.0283, -0.1100, 0.3013],
                 [0.2863, -0.1523, -0.6332, 1.0000, 0.3140, 0.2152, -0.1084, 0.4114, 0.1732],
                 [-0.0329, -0.2565, 0.2012, 0.3140, 1.0000, 0.3184, -0.1923, 0.3761, 0.8433],
                 [0.2925, -0.1605, -0.0578, 0.2152, 0.3184, 1.0000, 0.1246, 0.4736, 0.2078],
                 [-0.0588, 0.0874, 0.0283, -0.1084, -0.1923, 0.1246, 1.0000, 0.0752, -0.1578],
                 [0.3377, -0.2895, -0.1100, 0.4114, 0.3761, 0.4736, 0.0752, 1.0000, 0.2114],
                 [-0.1914, -0.2125, 0.3013, 0.1732, 0.8433, 0.2078, -0.1578, 0.2114, 1.0000]]),
      np.matrix([[1.0000, -0.1586, 0.1817, -0.0195, -0.0884, 0.0282, 0.0560, -0.1369, 0.0099],
                 [-0.1586, 1.0000, 0.0440, 0.1013, -0.2510, -0.0046, -0.1105, 0.0738, -0.1152],
                 [0.1817, 0.0440, 1.0000, -0.5118, 0.0414, 0.2570, 0.0932, 0.0961, 0.4938],
                 [-0.0195, 0.1013, -0.5118, 1.0000, 0.0480, -0.1155, -0.2463, -0.0754, 0.0204],
                 [-0.0884, -0.2510, 0.0414, 0.0480, 1.0000, 0.2577, -0.0581, 0.3152, 0.3151],
                 [0.0282, -0.0046, 0.2570, -0.1155, 0.2577, 1.0000, -0.1598, 0.4397, 0.1107],
                 [0.0560, -0.1105, 0.0932, -0.2463, -0.0581, -0.1598, 1.0000, -0.4617, 0.1872],
                 [-0.1369, 0.0738, 0.0961, -0.0754, 0.3152, 0.4397, -0.4617, 1.0000, -0.0114],
                 [0.0099, -0.1152, 0.4938, 0.0204, 0.3151, 0.1107, 0.1872, -0.0114, 1.0000]]),
    ]
  )

  k_trans = np.matrix(
    [[0.3700, 0.2200, 0.2200, 0.0000, 0.0000, 0.3700, 0.0000, 0.2300, 0.2200, 0.2200, 0.0000, 0.0000, 0.2300, 0.0000],
     [0.0000, 0.0200, 0.0200, 0.0000, 0.0000, 0.0000, 0.0100, 0.0100, 0.0200, 0.0200, 0.0000, 0.0000, 0.0100, 0.0100],
     [0.0000, 0.3600, 0.3600, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.3600, 0.3600, 0.0000, 0.0000, 0.0000, 0.0000],
     [0.0100, 0.0000, 0.0000, 0.0000, 0.0000, 0.0100, 0.0000, 0.1300, 0.0000, 0.0000, 0.0000, 0.0000, 0.1300, 0.0000],
     [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0200, 0.0000, 0.0000, 0.0000, 0.0000, 0.0200, 0.0000],
     [0.0000, 0.0200, 0.0200, 0.0200, 0.0200, 0.0000, 0.0000, 0.0000, 0.0200, 0.0200, 0.0200, 0.0200, 0.0000, 0.0000],
     [0.0100, 0.3600, 0.3600, 0.0000, 0.0000, 0.0100, 0.0000, 0.0000, 0.3600, 0.3600, 0.0000, 0.0000, 0.0000, 0.0000],
     [0.0000, 0.0000, 0.0000, 0.1200, 0.1200, 0.0000, 0.2600, 0.0000, 0.0000, 0.0000, 0.1200, 0.1200, 0.0000, 0.2600],
     [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]
  )

  N_sig = np.zeros((10, NTypesN))
  N_min = np.zeros((12, NTypesN))
  N_max = np.zeros((12, NTypesN))

  N_sig[1] = [0.4296, 0.0754, 0.0754, 0.3283, 0.3283, 0.4296, 0.5029,
              0.1472, 0.0754, 0.0754, 0.3283, 0.3283, 0.1472, 0.5029]
  N_sig[2] = [0.3558, 0.0046, 0.0046, 0.1844, 0.1844, 0.3558, 0.0022,
              0.0030, 0.0046, 0.0046, 0.1844, 0.1844, 0.0030, 0.0022]
  N_sig[3] = [0.3644, 0.3813, 0.3813, 0.3630, 0.3630, 0.3644, 0.3359,
              0.2846, 0.3813, 0.3813, 0.3630, 0.3630, 0.2846, 0.3359]
  N_sig[4] = [0.0048, 0.7107, 0.7107, 0.3568, 0.3568, 0.0048, 0.7395,
              0.0554, 0.7107, 0.7107, 0.3568, 0.3568, 0.0554, 0.7395]
  N_sig[5] = [0.5259, 0.5033, 0.5033, 0.4372, 0.4372, 0.5259, 0.3035,
              0.0062, 0.5033, 0.5033, 0.4372, 0.4372, 0.0062, 0.3035]
  N_sig[6] = [0.4947, 0.0052, 0.0052, 0.0170, 0.0170, 0.4947, 0.3186,
              0.6356, 0.0052, 0.0052, 0.0170, 0.0170, 0.6356, 0.3186]
  N_sig[7] = [0.0113, 1.9269, 1.9269, 1.4550, 1.4550, 0.0113, 1.0353,
              1.3712, 1.9269, 1.9269, 1.4550, 1.4550, 1.3712, 1.0353]
  N_sig[8] = [0.6104, 0.4817, 0.4817, 0.1504, 0.1504, 0.6104, 0.1813,
              0.3497, 0.4817, 0.4817, 0.1504, 0.1504, 0.3497, 0.1813]
  N_sig[9] = [0.4608, 0.4385, 0.4385, 0.4311, 0.4311, 0.4608, 0.3632,
              0.2857, 0.4385, 0.4385, 0.4311, 0.4311, 0.2857, 0.3632]

  N_min[1] = [61.4187, 42.1156, 42.1156, 51.8447, 51.8447, 61.4187, 32.3194,
              110.7272, 42.1156, 42.1156, 51.8447, 51.8447, 110.7272, 32.3194]  # C
  N_min[2] = [3.2940, 3.6802, 3.6802, 2.9852, 2.9852, 3.2940, 2.1462,
              3.4510, 3.6802, 3.6802, 2.9852, 2.9852, 3.4510, 2.1462]  # g_L
  N_min[3] = [-104.9627, -96.9345, -96.9345, -98.8335, -98.8335, -104.9627, -102.3895,
              -101.5624, -96.9345, -96.9345, -98.8335, -98.8335, -101.5624, -102.3895]  # E_L
  N_min[4] = [10.5568, 2.1840, 2.1840, 11.0503, 11.0503, 10.5568, 1.8285,
              12.7969, 2.1840, 2.1840, 11.0503, 11.0503, 12.7969, 1.8285]  # delta_T
  N_min[5] = [-62.5083, -60.6745, -60.6745, -65.4193, -65.4193, -62.5083, -42.8895,
              -66.1510, -60.6745, -60.6745, -65.4193, -65.4193, -66.1510, -42.8895]  # V_up
  N_min[6] = [54.0018, 10.2826, 10.2826, 12.2898, 12.2898, 54.0018, 20.0311,
              33.1367, 10.2826, 10.2826, 12.2898, 12.2898, 33.1367, 20.0311]  # tau_w
  N_min[7] = [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,
              0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]  # a
  N_min[8] = [1.2406, 1.0000, 1.0000, 1.0000, 1.0000, 1.2406, 1.0000,
              1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000]  # b
  N_min[9] = [-219.2039, -128.4559, -128.4559, -271.9846, -271.9846, -219.2039, -105.1880,
              -124.5158, -128.4559, -128.4559, -271.9846, -271.9846, -124.5158, -105.1880]  # V_r
  N_min[10] = [-63.2375, -85.2096, -85.2096, -70.3537, -70.3537, -63.2375, -53.3897,
               -69.5922, -85.2096, -85.2096, -70.3537, -70.3537, -69.5922, -53.3897]  # V_T
  N_min[11] = [10.3876, 7.3511, 7.3511, 9.2264, 9.2264, 10.3876, 5.8527,
               16.7015, 7.3511, 7.3511, 9.2264, 9.2264, 16.7015, 5.8527]  # I_ref ? V_dep ?

  N_max[1] = [337.9765, 94.6939, 94.6939, 126.2367, 126.2367, 337.9765, 201.3221,
              617.2776, 94.6939, 94.6939, 126.2367, 126.2367, 617.2776, 201.3221]
  N_max[2] = [10.8106, 8.6130, 8.6130, 5.6192, 5.6192, 10.8106, 5.3460,
              15.6329, 8.6130, 8.6130, 5.6192, 5.6192, 15.6329, 5.3460]
  N_max[3] = [-76.8526, -71.7548, -71.7548, -75.7868, -75.7868, -76.8526, -59.6898,
              -66.4770, -71.7548, -71.7548, -75.7868, -75.7868, -66.4770, -59.6898]
  N_max[4] = [45.3814, 40.4333, 40.4333, 31.3533, 31.3533, 45.3814, 47.6214,
              43.5882, 40.4333, 40.4333, 31.3533, 31.3533, 43.5882, 47.6214]
  N_max[5] = [-30.0577, -36.5929, -36.5929, -45.6445, -45.6445, -30.0577, -30.7977,
              -25.2891, -36.5929, -36.5929, -45.6445, -45.6445, -25.2891, -30.7977]
  N_max[6] = [232.8699, 21.9964, 21.9964, 120.5043, 120.5043, 232.8699, 102.4180,
              909.5520, 21.9964, 21.9964, 120.5043, 120.5043, 909.5520, 102.4180]
  N_max[7] = [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,
              0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]
  N_max[8] = [40.2930, 196.7634, 196.7634, 71.0958, 71.0958, 40.2930, 54.2781,
              325.7906, 196.7634, 196.7634, 71.0958, 71.0958, 325.7906, 54.2781]
  N_max[9] = [-45.0393, -56.5047, -56.5047, -56.8682, -56.8682, -45.0393, -35.7409,
              -35.1145, -56.5047, -56.5047, -56.8682, -56.8682, -35.1145, -35.7409]
  N_max[10] = [-36.8701, -39.1085, -39.1085, -49.0974, -49.0974, -36.8701, -20.6720,
               -27.8669, -39.1085, -39.1085, -49.0974, -49.0974, -27.8669, -20.6720]
  N_max[11] = [42.7304, 15.9128, 15.9128, 25.9839, 25.9839, 42.7304, 48.7992,
               67.7062, 15.9128, 15.9128, 25.9839, 25.9839, 67.7062, 48.7992]

  NeuPars = np.zeros((len(CellPar[:, 0]) + 2, num_column * N))
  NeuInit = np.zeros((2, num_column * N))

  ind_NeuPar = [i for i in range(0, 9)]
  valid_ind_NeuPar = [0, 1, 2, 3, 4, 5, 7, 8, 9]

  # -------------- Set neuron parameters -----------------

  neuron_group_indices = [[[] for j in range(num_column)] for i in range(NTypesN)]

  t_lat = np.zeros(N * num_column)
  t_lat_LIF = np.zeros(N * num_column)
  adapt = np.zeros(N * num_column)

  NN = 0
  for i_col in range(num_column):
    for i_typ in range(NTypesN):
      iset = (np.arange(NTypes[i_typ]) + NN).astype(int)
      neuron_group_indices[i_typ][i_col].extend(iset)
      ind_out = iset

      iii = 0
      while ind_out.size and iii < 999:
        # sampling neuronal parameters
        NeuPar_multi = np.random.multivariate_normal(np.zeros(len(ParCov[i_typ][:, 0])),
                                                     ParCov[i_typ],
                                                     len(ind_out)).transpose()
        for j_typ in ind_NeuPar:
          NeuPar_multi[j_typ] = inv_transform_distribution2(NeuPar_multi[j_typ],
                                                            k_trans[j_typ, i_typ],
                                                            CellPar[j_typ + 1, i_typ],
                                                            N_sig[j_typ + 1, i_typ],
                                                            N_min[valid_ind_NeuPar[j_typ] + 1, i_typ])
        for j_typ in ind_NeuPar:
          NeuPars[valid_ind_NeuPar[j_typ], ind_out] = NeuPar_multi[j_typ]
        NeuPars[0, ind_out] = NeuPars[0, ind_out] * NeuPars[1, ind_out]  # C from gL and tau

        # filtering out invalid parameters
        ind_out_para = np.asarray([])
        for j_typ in valid_ind_NeuPar:
          bound_idc = np.where(np.logical_or(NeuPars[j_typ, iset] < N_min[j_typ + 1, i_typ],
                                             NeuPars[j_typ, iset] > N_max[j_typ + 1, i_typ]))[0]
          ind_out_para = np.concatenate((ind_out_para, bound_idc))
        ind_out_V2 = np.where((NeuPars[8, iset] >= NeuPars[9, iset]))[0]  # Vr must be smaller than Vth
        ind_out_tau = np.where(
          (NeuPars[0, iset] / NeuPars[1, iset] < N_min[11, i_typ]) |
          (NeuPars[0, iset] / NeuPars[1, iset] > N_max[11, i_typ])
        )[0]  # check tau boundaries)
        ind_out_tcw = np.where((NeuPars[5, iset] <= NeuPars[0, iset] / NeuPars[1, iset]))[0]
        ind_out_nan = np.argwhere(np.isnan(NeuPars[:, iset]))[:, 1]
        all_idc = np.concatenate((ind_out_para, ind_out_V2, ind_out_tau, ind_out_tcw, ind_out_nan))

        ind_out = iset[np.unique(all_idc).astype(int)]
        iii = iii + 1
      if ind_out.size:
        print('ERROR: Number of trials for multi-variate normal distribution has been exceeded.\n')

      t_lat_act = np.zeros(np.size(iset))
      t_lat_LIF_act = np.zeros(np.size(iset))
      adapt_act = np.zeros(np.size(iset))
      for j_typ in range(len(iset)):
        I = 500
        C = NeuPars[0, iset[j_typ]]
        gL = NeuPars[1, iset[j_typ]]
        EL = NeuPars[2, iset[j_typ]]
        sf = NeuPars[3, iset[j_typ]]
        Vup = NeuPars[4, iset[j_typ]]
        tcw = NeuPars[5, iset[j_typ]]
        b = NeuPars[7, iset[j_typ]]
        Vr = NeuPars[8, iset[j_typ]]
        Vth = NeuPars[9, iset[j_typ]]
        Irheo = gL * (Vth - EL) - gL * sf
        Iref = fmin(Define_I_ref, Irheo + 100, disp=False, args=(NeuPars[:, iset[j_typ]],))
        NeuPars[10, iset[j_typ]] = Iref
        NeuPars[11, iset[j_typ]] = Vr

        t_lat_act[j_typ] = quad(lambda V: C / (I - gL * (V - EL) + gL * sf * np.exp((V - Vth) / sf)), EL, Vth / 2)[0]
        t_lat_LIF_act[j_typ] = C * np.log(I / (I + gL * (EL - Vth / 2))) / gL

        I = [i for i in range(25, 301, 25)]
        f1 = np.zeros(len(I))
        f2 = np.zeros(len(I))
        for k in range(len(I)):
          f1[k] = FRsimpAdEx(NeuPars[:, iset[j_typ]], I[k], 0, NeuPars[2, iset[j_typ]], [])
          f2[k] = FRsimpAdEx(NeuPars[:, iset[j_typ]], I[k], [], [], [])

        idc0 = np.where(f2 > 0)[0]
        if np.isnan(np.median(f1[idc0] / f2[idc0])):
          adapt_act[j_typ] = 0
        else:
          adapt_act[j_typ] = np.median(f1[idc0] / f2[idc0])
      t_lat[iset] = t_lat_act
      t_lat_LIF[iset] = t_lat_LIF_act
      adapt[iset] = adapt_act

      # initial neuron variables
      NeuInit[0, iset] = NeuPars[2, iset]
      NeuInit[1, iset] = np.zeros((1, len(iset)))

      NN += NTypes[i_typ]

    # Redistribute neuron types: I-L -> I-L-d
    ind_L23 = np.asarray(neuron_group_indices[1][i_col] + neuron_group_indices[2][i_col])
    if len(ind_L23 > 0):
      ind_L23_Ld = ind_L23[(t_lat[ind_L23] - t_lat_LIF[ind_L23]) > 0]
      ind_L23_L = np.setdiff1d(ind_L23, ind_L23_Ld)
      NTypes[1] = len(ind_L23_L)
      NTypes[2] = len(ind_L23_Ld)
      neuron_group_indices[1][i_col] = list(ind_L23_L)
      neuron_group_indices[2][i_col] = list(ind_L23_Ld)
    ind_L5 = np.asarray(neuron_group_indices[8][i_col] + neuron_group_indices[9][i_col])
    if len(ind_L5) > 0:
      ind_L5_Ld = ind_L5[((t_lat[ind_L5] - t_lat_LIF[ind_L5]) > 0)]
      ind_L5_L = np.setdiff1d(ind_L5, ind_L5_Ld)
      NTypes[8] = len(ind_L5_L)
      NTypes[9] = len(ind_L5_Ld)
      neuron_group_indices[8][i_col] = list(ind_L5_L)
      neuron_group_indices[9][i_col] = list(ind_L5_Ld)

    # Redistribute neuron types: I-CL -> I-CL-AC
    ind_L23 = np.asarray(neuron_group_indices[3][i_col] + neuron_group_indices[4][i_col])
    if len(ind_L23) > 0:
      ind_L23_Ld = ind_L23[adapt[ind_L23] > 1.5834]
      ind_L23_L = np.setdiff1d(ind_L23, ind_L23_Ld)
      NTypes[3] = len(ind_L23_L)
      NTypes[4] = len(ind_L23_Ld)
      neuron_group_indices[3][i_col] = list(ind_L23_L)
      neuron_group_indices[4][i_col] = list(ind_L23_Ld)
    ind_L5 = np.asarray(neuron_group_indices[10][i_col] + neuron_group_indices[11][i_col])
    if len(ind_L5) > 0:
      ind_L5_Ld = ind_L5[adapt[ind_L5] > 1.5834]
      ind_L5_L = np.setdiff1d(ind_L5, ind_L5_Ld)
      NTypes[10] = len(ind_L5_L)
      NTypes[11] = len(ind_L5_Ld)
      neuron_group_indices[10][i_col] = list(ind_L5_L)
      neuron_group_indices[11][i_col] = list(ind_L5_Ld)

  print('REPORT: Neuronal parameters generated\n')

  return NeuPars, NeuInit, neuron_group_indices


def setup_synapse_params(num_per_column, num_column, group_indices, scales, clustering=True):
  # gmax_scale: [1. E -> E gmax scale,
  #              2. I -> E gmax scale,
  #              3. E -> I gmax scale,
  #              4. I -> I gmax scale]
  # pCon_scale: [1. E -> E conn prob scale,
  #              2. I -> E conn prob scale,
  #              3. E -> I conn prob scale,
  #              4. I -> I conn prob scale]
  # param_std_scale: (10, 14)
  #                  Scale of std of membrane parameters for each group
  gmax_scale, pCon_scale, param_std_scale = scales

  STSP_E1 = np.asarray([[0.28, 194, 507],  # mean
                        [0.02, 18., 37.]])  # std
  STSP_E2 = np.asarray([[0.25, 671, 17],
                        [0.02, 17, 5]])
  STSP_E3 = np.asarray([[0.29, 329, 326],
                        [0.03, 53, 66]])

  STSP_I1 = np.asarray([[0.16, 45, 376],
                        [0.10, 21, 253]])
  STSP_I2 = np.asarray([[0.25, 706, 21],
                        [0.13, 405, 9]])
  STSP_I3 = np.asarray([[0.32, 144, 62],
                        [0.14, 80, 31]])

  STSP_setup = {
    'E1': STSP_E1,
    'E2': STSP_E2,
    'E3': STSP_E3,
    'I1': STSP_I1,
    'I2': STSP_I2,
    'I3': STSP_I3,
  }

  get_SynType = {1: [1, 3],
                 2: [2]}

  get_STSP_prob = {
    1: [1],
    2: [0.45, 0.38, 0.17],
    3: [0.25, 0.50, 0.25],
    4: [0.29, 0.58, 0.13],
    0: [],
  }

  get_STSP_types = {
    1: ['E1'],
    2: ['E2'],
    3: ['E1', 'E2', 'E3'],
    11: ['I2'],
    12: ['I1', 'I2', 'I3'],
    0: [],
  }

  gmax_scale_EE = gmax_scale[0]
  gmax_scale_IE = gmax_scale[1]
  gmax_scale_EI = gmax_scale[2]
  gmax_scale_II = gmax_scale[3]

  Synpfail = np.zeros((14, 14))
  Synpfail[:] = 0.3

  # synaptic types #
  # -------------- #
  SynTypes = np.zeros((14, 14))
  SynTypes[:, 0] = 1  # 1: excitatory; 2: inhibitory
  SynTypes[:, 1:7] = 2
  SynTypes[:, 7] = 1
  SynTypes[:, 8:14] = 2

  # synaptic type parameters #
  # ------------------------ #
  STypPar = np.zeros((8, 3))
  STypPar[0] = [1, 1, 1.09]
  STypPar[1] = [1.4, 3.0, 4.3]  # tau_on
  STypPar[2] = [10, 40, 75]  # tau_off
  STypPar[3] = [0, -70, 0]  # E
  STypPar[4] = [0, 0, 1]
  STypPar[5] = [0, 0, 0.33]  # fac
  STypPar[6] = [0, 0, 0.0625]  # slope
  STypPar[7] = [0, 0, 0]  # half

  # synaptic conductance #
  # -------------------- #
  Syn_gmax_non_scaled = np.zeros((14, 14))
  Syn_gmax_non_scaled[0, 0:14] = [0.8405, 2.2615, 2.2615, 0.1800, 0.1800, 2.2615, 1.8218,
                                  0.8378, 0.2497, 0.2497, 0.0556, 0.0556, 0.2497, 0.2285]
  Syn_gmax_non_scaled[7, 0:14] = [0.9533, 1.0503, 1.0503, 0.0836, 0.0836, 1.0503, 0.8461,
                                  0.8818, 1.7644, 1.7644, 0.3932, 0.3932, 1.7644, 1.6146]
  Syn_gmax_non_scaled[1:7, 0] = [1.3403, 1.3403, 0.4710, 0.4710, 1.3403, 0.2500]
  Syn_gmax_non_scaled[8:14, 0] = [1.5201, 1.5201, 0.5342, 0.5342, 1.5201, 0.2835]
  Syn_gmax_non_scaled[1:7, 7] = [0.7738, 0.7738, 0.2719, 0.2719, 0.7738, 0.1443]
  Syn_gmax_non_scaled[8:14, 7] = [1.7431, 1.7431, 0.88, 0.88, 1.7431, 0.28]
  Syn_gmax_non_scaled[1:7, 1:7] = 1.35
  Syn_gmax_non_scaled[8:14, 8:14] = 1.35

  Syngmax = np.zeros((14, 14))
  for i in [0, 7]:
    for j in [0, 7]:
      Syngmax[i, j] = get_gmax(Syn_gmax_non_scaled[i, j], i, j) * gmax_scale_EE
  for i in [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13]:
    for j in [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13]:
      Syngmax[i, j] = get_gmax(Syn_gmax_non_scaled[i, j], i, j) * gmax_scale_II
  for i in [0, 7]:
    for j in [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13]:
      Syngmax[i, j] = get_gmax(Syn_gmax_non_scaled[i, j], i, j) * gmax_scale_IE
  for i in [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13]:
    for j in [0, 7]:
      Syngmax[i, j] = get_gmax(Syn_gmax_non_scaled[i, j], i, j) * gmax_scale_EI

  # synaptic delays #
  # --------------- #
  syn_delay = np.zeros((14, 14))

  syn_delay[0, 0] = 1.5465
  syn_delay[0, 1:7] = 1.2491
  syn_delay[0, 7] = 2.7533
  syn_delay[0, 8:14] = 1.4411

  syn_delay[7, 0] = 1.9085
  syn_delay[7, 1:7] = 1.5415
  syn_delay[7, 7] = 1.5667
  syn_delay[7, 8:14] = 0.82

  syn_delay[1:7, 0] = 0.9581
  syn_delay[8:14, 0] = 1.1825
  syn_delay[1:7, 7] = 1.0544
  syn_delay[8:14, 7] = 0.6

  syn_delay[1:7, 1:7] = 1.1
  syn_delay[8:14, 8:14] = 1.1

  # STP types       #
  # --------------- #
  STSP_prob = np.zeros((14, 14))
  STSP_types = np.zeros((14, 14))

  STSP_prob[0, 0] = 2
  STSP_prob[0, 7] = 2
  STSP_prob[7, 0] = 2
  STSP_prob[7, 7] = 2

  STSP_prob[1:7, 0] = 1
  STSP_prob[1:7, 7] = 1
  STSP_prob[8:14, 0] = 1
  STSP_prob[8:14, 7] = 1

  STSP_prob[0, 1] = 3
  STSP_prob[0, 8] = 3
  STSP_prob[7, 1] = 3
  STSP_prob[7, 8] = 3

  STSP_prob[0, 2:7] = 1
  STSP_prob[0, 9:14] = 1
  STSP_prob[7, 2:7] = 1
  STSP_prob[7, 9:14] = 1

  STSP_prob[1:7, 1:7] = 4
  STSP_prob[8:14, 8:14] = 4

  STSP_types[0, 0] = 3
  STSP_types[0, 7] = 3
  STSP_types[7, 0] = 3
  STSP_types[7, 7] = 3

  STSP_types[1, 0] = 1
  STSP_types[1, 7] = 1
  STSP_types[8, 0] = 1
  STSP_types[8, 7] = 1

  STSP_types[2:4, 0] = 2
  STSP_types[2:4, 7] = 2
  STSP_types[9:11, 0] = 2
  STSP_types[9:11, 7] = 2

  STSP_types[4, 0] = 1
  STSP_types[4, 7] = 1
  STSP_types[11, 0] = 1
  STSP_types[11, 7] = 1

  STSP_types[5, 0] = 2
  STSP_types[5, 7] = 2
  STSP_types[12, 0] = 2
  STSP_types[12, 7] = 2

  STSP_types[6, 0] = 1
  STSP_types[6, 7] = 1
  STSP_types[13, 0] = 1
  STSP_types[13, 7] = 1

  STSP_types[0, 1] = 12
  STSP_types[0, 8] = 12
  STSP_types[7, 1] = 12
  STSP_types[7, 8] = 12

  STSP_types[0, 2:7] = 11
  STSP_types[0, 9:14] = 11
  STSP_types[7, 2:7] = 11
  STSP_types[7, 9:14] = 11

  STSP_types[1:7, 1:7] = 12
  STSP_types[8:14, 8:14] = 12

  # connection probability #
  # ---------------------- #
  pCon = np.zeros((14, 14))

  pCon[0, 0] = pCon_scale[0] * 0.1393
  pCon[0, 7] = pCon_scale[0] * 0.0449
  pCon[7, 0] = pCon_scale[0] * 0.2333
  pCon[7, 7] = pCon_scale[0] * 0.0806

  pCon[1:3, 0] = pCon_scale[1] * 0.3247
  pCon[1:3, 7] = pCon_scale[1] * 0.1875
  pCon[8:10, 0] = pCon_scale[1] * 0.0870
  pCon[8:10, 7] = pCon_scale[1] * 0.3331
  pCon[3:5, 0] = pCon_scale[1] * 0.1594
  pCon[3:5, 7] = pCon_scale[1] * 0.0920
  pCon[10:12, 0] = pCon_scale[1] * 0.0800
  pCon[10:12, 7] = pCon_scale[1] * 0.0800
  pCon[5, 0] = pCon_scale[1] * 0.3247
  pCon[5, 7] = pCon_scale[1] * 0.1875
  pCon[12, 0] = pCon_scale[1] * 0.0870
  pCon[12, 7] = pCon_scale[1] * 0.3331
  pCon[6, 0] = pCon_scale[1] * 0.2900
  pCon[6, 7] = pCon_scale[1] * 0.1674
  pCon[13, 0] = pCon_scale[1] * 0.1500
  pCon[13, 7] = pCon_scale[1] * 0.3619

  pCon[0, 1:3] = pCon_scale[2] * 0.4586
  pCon[0, 8:10] = pCon_scale[2] * 0.0991
  pCon[7, 1:3] = pCon_scale[2] * 0.2130
  pCon[7, 8:10] = pCon_scale[2] * 0.7006
  pCon[0, 3:5] = pCon_scale[2] * 0.4164
  pCon[0, 10:12] = pCon_scale[2] * 0.0321
  pCon[7, 3:5] = pCon_scale[2] * 0.1934
  pCon[7, 10:12] = pCon_scale[2] * 0.2271
  pCon[0, 5] = pCon_scale[2] * 0.4586
  pCon[0, 12] = pCon_scale[2] * 0.0991
  pCon[7, 5] = pCon_scale[2] * 0.2130
  pCon[7, 12] = pCon_scale[2] * 0.7006
  pCon[0, 6] = pCon_scale[2] * 0.6765
  pCon[0, 13] = pCon_scale[2] * 0.1287
  pCon[7, 6] = pCon_scale[2] * 0.3142
  pCon[7, 13] = pCon_scale[2] * 0.9096

  pCon[1:7, 1:7] = pCon_scale[3] * 0.25
  pCon[8:14, 8:14] = pCon_scale[3] * 0.60

  # clustering flag #
  # --------------- #
  cluster_flag = np.zeros((14, 14))
  cluster_flag[0, 0] = 1
  cluster_flag[7, 7] = 1

  # synaptic weight #
  # --------------- #

  S_sig = np.zeros((14, 14, 2))  # sigma
  S_max = np.zeros((14, 14, 2))  # maximum
  S_min = np.zeros((14, 14, 2))  # minimum

  S_sig[0, 0, 0] = 0.4695
  S_sig[0, 7, 0] = 0.1375
  S_sig[7, 0, 0] = 0.3530
  S_sig[7, 7, 0] = 0.9653

  S_sig[1:3, 0, 0] = 1.0855
  S_sig[1:3, 7, 0] = 0.6267
  S_sig[8:10, 0, 0] = 0.8588
  S_sig[8:10, 7, 0] = 1.1194

  S_sig[3:5, 0, 0] = 0.1999
  S_sig[3:5, 7, 0] = 0.1154
  S_sig[10:12, 0, 0] = 0.1581
  S_sig[10:12, 7, 0] = 0.7033

  S_sig[5, 0, 0] = 1.0855
  S_sig[5, 7, 0] = 0.6267
  S_sig[12, 0, 0] = 0.8588
  S_sig[12, 7, 0] = 1.1194

  S_sig[6, 0, 0] = 0.2000
  S_sig[6, 7, 0] = 0.1155
  S_sig[13, 0, 0] = 0.1582
  S_sig[13, 7, 0] = 0.3000

  S_sig[0, 1:3, 0] = 1.9462
  S_sig[0, 8:10, 0] = 0.0362
  S_sig[7, 1:3, 0] = 0.9038
  S_sig[7, 8:10, 0] = 0.2557

  S_sig[0, 3:5, 0] = 0.6634
  S_sig[0, 10:12, 0] = 0.0093
  S_sig[7, 3:5, 0] = 0.3081
  S_sig[7, 10:12, 0] = 0.0655

  S_sig[0, 5, 0] = 1.9462
  S_sig[0, 12, 0] = 0.0362
  S_sig[7, 5, 0] = 0.9038
  S_sig[7, 12, 0] = 0.2557

  S_sig[0, 6, 0] = 3.6531
  S_sig[0, 13, 0] = 0.1828
  S_sig[7, 6, 0] = 1.6966
  S_sig[7, 13, 0] = 1.2919

  S_sig[1:7, 1:7, 0] = 0.35
  S_sig[8:14, 8:14, 0] = 0.35

  S_sig[0, 0, 1] = 0.3095
  S_sig[0, 7, 1] = 0.1825
  S_sig[7, 0, 1] = 0.1651
  S_sig[7, 7, 1] = 0.4350

  S_sig[1:7, 0, 1] = 0.2489
  S_sig[1:7, 7, 1] = 0.0839
  S_sig[8:14, 0, 1] = 0.1327
  S_sig[8:14, 7, 1] = 0.2000

  S_sig[0, 1:7, 1] = 0.1786
  S_sig[0, 8:14, 1] = 0.0394
  S_sig[7, 1:7, 1] = 0.0940
  S_sig[7, 8:14, 1] = 0.0940

  S_sig[1:7, 1:7, 1] = 0.4
  S_sig[8:14, 8:14, 1] = 0.4

  S_max[:, :, 0] = 100
  S_max[:, :, 1] = 2

  # -------------- Set most synaptic connections -----------------

  NTypes = np.ceil(num_per_column * neu_type_ratio)
  NTypesN = len(NTypes)
  N = int(round(np.sum(NTypes), 0))

  all_conn = np.zeros((3, N, N), dtype=bool)
  all_use = np.zeros((3, N, N))
  all_tau_rec = np.zeros((3, N, N))
  all_tau_fac = np.zeros((3, N, N))
  all_g_max = np.zeros((3, N, N))

  for i_col in range(num_column):
    # ------ intra-cell-type connections ------
    for i_typ in range(NTypesN):
      if len(group_indices[i_typ][i_col]):

        # ---- connection matrix ----
        if cluster_flag[i_typ, i_typ] and clustering:
          # X: the connection matrix, the element value indicate the synapse index
          # idc: the synaptic index
          X, n_conn = SetCon_CommonNeighbour_Recur(len(group_indices[i_typ][i_col]),
                                                   pCon[i_typ, i_typ],
                                                   0.47)
        else:
          X, n_conn = _set_conn(len(group_indices[i_typ][i_col]),
                                len(group_indices[i_typ][i_col]),
                                pCon[i_typ, i_typ])  # ... or without common neighbour rule

        # ---- synaptic parameters ----
        if n_conn > 0:
          pres = np.asarray(group_indices[i_typ][i_col])
          iii1, iii2 = np.where(X)
          Idc1 = pres[iii1]
          Idc2 = pres[iii2]
          SynTypes_act = get_SynType[SynTypes[i_typ, i_typ]]
          for k, syn_type in enumerate(SynTypes_act):
            # synaptic variables
            SynPar = _set_syn(n_conn,
                              Syngmax[i_typ, i_typ],
                              syn_delay[i_typ, i_typ],
                              Synpfail[i_typ, i_typ],
                              STSP_types[i_typ, i_typ],
                              STSP_prob[i_typ, i_typ],
                              get_STSP_prob,
                              get_STSP_types,
                              STSP_setup,
                              S_sig[i_typ, i_typ],
                              S_max[i_typ, i_typ],
                              S_min[i_typ, i_typ])
            # synaptic parameters
            all_conn[syn_type - 1, Idc1, Idc2] = 1
            all_use[syn_type - 1, Idc1, Idc2] = SynPar[1]
            all_tau_rec[syn_type - 1, Idc1, Idc2] = SynPar[2]
            all_tau_fac[syn_type - 1, Idc1, Idc2] = SynPar[3]
            all_g_max[syn_type - 1, Idc1, Idc2] = SynPar[4]

    # ------ inter-cell-type connections ------
    for i_typ in range(NTypesN):  # loop over output neurons
      for j_typ in range(NTypesN):  # loop over input neurons (except output neuron)
        if i_typ != j_typ and len(group_indices[i_typ][i_col]) and len(group_indices[j_typ][i_col]):
          X, n_conn = _set_conn(len(group_indices[i_typ][i_col]),
                                len(group_indices[j_typ][i_col]),
                                pCon[i_typ, j_typ])
          if n_conn > 0:
            pres = np.asarray(group_indices[i_typ][i_col])
            posts = np.asarray(group_indices[j_typ][i_col])
            iii1, iii2 = np.where(X)
            Idc1 = pres[iii1]
            Idc2 = posts[iii2]
            SynTypes_act = get_SynType[SynTypes[i_typ, j_typ]]
            for k, syn_type in enumerate(SynTypes_act):
              # set synapse parameters / +2 replaced by +1
              SynPar = _set_syn(n_conn,
                                Syngmax[i_typ, j_typ],
                                syn_delay[i_typ, j_typ],
                                Synpfail[i_typ, j_typ],
                                STSP_types[i_typ, j_typ],
                                STSP_prob[i_typ, j_typ],
                                get_STSP_prob,
                                get_STSP_types,
                                STSP_setup,
                                S_sig[i_typ, j_typ, :],
                                S_max[i_typ, j_typ, :2],
                                S_min[i_typ, j_typ, :])
              # synaptic parameters
              all_conn[syn_type - 1, Idc1, Idc2] = 1
              all_use[syn_type - 1, Idc1, Idc2] = SynPar[1]
              all_tau_rec[syn_type - 1, Idc1, Idc2] = SynPar[2]
              all_tau_fac[syn_type - 1, Idc1, Idc2] = SynPar[3]
              all_g_max[syn_type - 1, Idc1, Idc2] = SynPar[4]

  exe_indices = []
  inh_indices = []
  for i, dist in enumerate(group_indices):
    if i in [0, 7]:
      exe_indices.extend(dist[0])
    else:
      inh_indices.extend(dist[0])
  exe_indices, inh_indices = np.asarray(exe_indices), np.asarray(inh_indices)
  exe_conn = all_conn[0, :, exe_indices]
  inh_conn = all_conn[1, :, inh_indices]

  ampa_U = all_use[0, :, exe_indices]
  gaba_U = all_use[1, :, inh_indices]
  nmda_U = all_use[2, :, exe_indices]

  ampa_tau_d = all_tau_rec[0, :, exe_indices]
  gaba_tau_d = all_tau_rec[1, :, inh_indices]
  nmda_tau_d = all_tau_rec[2, :, exe_indices]

  ampa_tau_f = all_tau_fac[0, :, exe_indices]
  gaba_tau_f = all_tau_fac[1, :, inh_indices]
  nmda_tau_f = all_tau_fac[2, :, exe_indices]

  ampa_g_max = all_g_max[0, :, exe_indices]
  gaba_g_max = all_g_max[1, :, inh_indices]
  nmda_g_max = all_g_max[2, :, exe_indices]

  print('REPORT: Synaptic connectivity and parameters generated\n')
  return {'exe_conn': exe_conn, 'inh_conn': inh_conn,
          'exe_indices': exe_indices, 'inh_indices': inh_indices,
          'ampa_U': ampa_U, 'gaba_U': gaba_U, 'nmda_U': nmda_U,
          'ampa_tau_d': ampa_tau_d, 'gaba_tau_d': gaba_tau_d, 'nmda_tau_d': nmda_tau_d,
          'ampa_tau_f': ampa_tau_f, 'gaba_tau_f': gaba_tau_f, 'nmda_tau_f': nmda_tau_f,
          'ampa_g_max': ampa_g_max, 'gaba_g_max': gaba_g_max, 'nmda_g_max': nmda_g_max}


def get_gmax(PSP, i, j):
  par_E = [1.0569, 0.5875, 0.6587, 0.7567, 0.6728, 0.9899, 0.6294,
           1.6596, 0.5941, 0.6661, 0.7647, 0.6799, 1.5818, 0.6360]
  par_I = [2.3859, 1.6277, 1.6277, 1.6671, 1.6671, 2.3142, 1.4363,
           3.5816, 1.6277, 1.6277, 1.6671, 1.6671, 3.4016, 1.4363]
  if j in [0, 7]:
    gmax = PSP * par_E[i]
  else:
    gmax = PSP * par_I[i]
  return gmax


@numba.njit(fastmath=True, nogil=True)
def _set_conn(n_in, n_out, p_conn):
  X = np.random.rand(n_in, n_out) < p_conn
  n_connected = np.sum(X)
  return X, n_connected


def _set_syn(num_syn, gmax, delay, p_fail, STSP_types, STSP_prob,
             get_STSP_prob, get_STSP_types, STSP_setup, S_sig, S_max, S_min):
  syn_pars = np.zeros((7, num_syn))

  # g_max
  mean_gmax = np.log((gmax ** 2) / np.sqrt(S_sig[0] ** 2 + gmax ** 2))
  std_gmax = np.sqrt(np.log(S_sig[0] ** 2 / gmax ** 2 + 1))
  if gmax == 0 or S_sig[0] == 0:
    syn_pars[4] = rand_par(num_syn, gmax, S_sig[0], S_min[0] * gmax, S_max[0] * gmax, 0)
  else:
    syn_pars[4] = rand_par(num_syn, mean_gmax, std_gmax, S_min[0] * gmax, S_max[0] * gmax, 2)

  # delay
  syn_pars[5] = rand_par(num_syn, delay, S_sig[1], S_min[1] * delay, S_max[1] * delay, 0)

  # failure rate
  syn_pars[6] = p_fail

  # fraction / number of STP synapses
  ConParSTSP0_arr = np.asarray(get_STSP_prob[STSP_prob])
  idc_frac = (np.round(ConParSTSP0_arr * num_syn)).astype(int)
  if sum(idc_frac) > num_syn:
    ind = np.argmin(ConParSTSP0_arr * num_syn - np.floor(ConParSTSP0_arr * num_syn))
    idc_frac[ind] = idc_frac[ind] - 1
  elif sum(idc_frac) < num_syn:
    ind = np.argmax(idc_frac - np.floor(idc_frac))
    idc_frac[ind] = idc_frac[ind] + 1

  idc_act = np.arange(idc_frac[0]).astype(int)
  Nsyn_act = idc_frac[0]
  STSP = get_STSP_types[STSP_types]
  for i in range(len(ConParSTSP0_arr)):
    STSP_params = STSP_setup[STSP[i]]
    use = STSP_params[0, 0]
    tc_rec = STSP_params[0, 1]
    tc_fac = STSP_params[0, 2]
    std_use = STSP_params[1, 0]
    std_tc_rec = STSP_params[1, 1]
    std_tc_fac = STSP_params[1, 2]

    # use
    syn_pars[1, idc_act] = rand_par(len(idc_act), use, std_use, 0, 1, 0)
    # tau_rec
    syn_pars[2, idc_act] = rand_par(len(idc_act), tc_rec, std_tc_rec, 0, 1500, 0)
    # tau_fac
    syn_pars[3, idc_act] = rand_par(len(idc_act), tc_fac, std_tc_fac, 0, 1500, 0)

    if i + 1 < len(ConParSTSP0_arr) and len(ConParSTSP0_arr) > 1:
      idc_act = (Nsyn_act + np.arange(idc_frac[i + 1])).astype(int)  # +1 taken out
      Nsyn_act = Nsyn_act + idc_frac[i + 1]

  return syn_pars


def source_target(SPMtx):
  target_arr = np.zeros((np.max(SPMtx).astype(int)))
  source_arr = np.zeros((np.max(SPMtx).astype(int)))

  for i in range(SPMtx.shape[0]):  # target
    for j in range(SPMtx.shape[1]):  # source
      _ = SPMtx[i, j, 0].astype(int)
      if _ > 0:
        _ -= 1
        target_arr[_] = i
        source_arr[_] = j
        _ = SPMtx[i, j, 1].astype(int)
        if _ > 0:
          _ -= 1
          target_arr[_] = i
          source_arr[_] = j

  return target_arr.astype(int), source_arr.astype(int)


def inv_transform_distribution2(X_trans, k, mean_X, std_X, min_X):
  std_decr = 0.8

  if k > 0:
    if min_X < 0:
      X_inv = (mean_X + std_decr * std_X * X_trans) ** (1 / k) + 1.1 * min_X
    else:
      X_inv = (mean_X + std_decr * std_X * X_trans) ** (1 / k)

  else:
    if min_X < 0:
      X_inv = np.exp(mean_X + std_decr * std_X * X_trans) + 1.1 * min_X;
    else:
      X_inv = np.exp(mean_X + std_decr * std_X * X_trans)

  return X_inv


def FRsimpAdEx(values, I, w0=[], V0=[], bmin=[]):
  Cm, gL, EL, sf, Vup, tcw, a, b, Vr, Vth = values[:10]

  tau = Cm / gL
  f = tau / tcw
  X_Vth = f * (I + gL * sf - gL * (Vth - EL))
  w_end = -gL * (Vth - EL) + gL * sf + I - X_Vth

  if not np.size(w0):
    if b != 0:
      w_r = w_end + b
    else:
      w_r = 0
  else:
    w_r = w0

  if not np.size(bmin) or bmin < 0:
    bmin = 0;

  if not np.size(V0):
    V_r = Vr
  else:
    V_r = V0

  if (X_Vth <= 0 or f >= 1 or b < bmin or Cm <= 0 or gL <= 0 or tcw <= 0 or sf <= 0):
    fr = 0
  else:
    X_Vr = f * (I + gL * sf * np.exp((V_r - Vth) / sf) - gL * (V_r - EL))
    wV_Vr = -gL * (V_r - EL) + gL * sf * np.exp((V_r - Vth) / sf) + I
    w1 = wV_Vr - X_Vr
    w2 = wV_Vr + X_Vr

    t1 = 0
    t2 = 0
    if V_r >= Vth:
      if w_r >= wV_Vr:
        w_ref = -gL * (Vth - EL) + gL * sf + I + X_Vth
        Vfix = IntPoints_simpAdEx(values, I, w_r, w_ref, 1)
        i = 0
        j = w_r
        k = 0
        if (not Vfix or len(Vfix) == 1):
          t1 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), V_r, Vth)[0]
          t2 = 0
        else:
          Vlb = np.min(Vfix)
          t1 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), V_r, Vlb)[0]
          m = f * gL - gL
          i = m
          j = (1 - f) * I - m * EL
          k = (1 - f) * gL * sf
          t2 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), Vlb, Vth)[0]

        w_stop = w_end
        Vlb = Vth

      else:
        Vlb = V_r
        w_stop = w_r

    else:
      if (w_r < w2 and w_r > w1):
        m = f * gL - gL;
        i = m
        j = (1 - f) * I - m * EL
        k = (1 - f) * gL * sf
        t2 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), V_r, Vth)[0]
        w_stop = w_end
      else:
        i = 0
        j = w_r
        k = 0

        if (w_r <= w1):
          ns = -1
          w_ref = -gL * (Vth - EL) + gL * sf + I - X_Vth
        else:
          ns = 1
          w_ref = -gL * (Vth - EL) + gL * sf + I + X_Vth  # w_end

        Vfix = IntPoints_simpAdEx(values, I, w_r, w_ref, ns)

        if (not Vfix or len(Vfix) == 1):
          t1 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), V_r, Vth)[0]
          w_stop = w_r
        else:
          Vlb = np.min(Vfix)
          t1 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), V_r, Vlb)[0]
          m = f * gL - gL
          i = m
          j = (1 - f) * I - m * EL
          k = (1 - f) * gL * sf
          t2 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), Vlb, Vth)[0]
          w_stop = w_end

      Vlb = Vth

    if Vlb >= Vup:
      t3 = 0
    else:
      i = 0
      j = w_stop
      k = 0
      t3 = quad(lambda x: ISI_int_piecewise(x, I, values, i, j, k), Vlb, Vup)[0]

    ISI = np.asarray(t1 + t2 + t3)
    fr = 1000 / ISI

    return fr


def ISI_int_piecewise(V, I, values, i, j, k):
  Cm, gL, EL, sf, Vup, tcw, a, b, Vr, Vth = values[:10]

  F = (1 / Cm) * (I - (i * V + j + k * np.exp((V - Vth) / sf)) + gL * sf * np.exp((V - Vth) / sf) - gL * (V - EL))
  f = 1 / F

  return f


def IntPoints_simpAdEx(values, I, w0, w_ref, i):
  Cm, gL, EL, sf, Vup, tcw, a, b, Vr, Vth = values[:10]
  numcor = 0

  Vfix = [None, None]

  if w0 > w_ref:
    f = Cm / (gL * tcw)
    G = lambda V: ((1 + i * f) * (I - gL * (V - EL) + gL * sf * np.exp((V - Vth) / sf)) - w0)

    lb = EL + (I - (w0 / (1 + i * f))) / gL - 0.1
    ub = EL + sf + (I - (w0 / (1 + i * f))) / gL

    while (np.sign(G(ub)) / np.sign(G(lb)) == 1):
      lb = EL + (I - (w0 / (1 + i * f))) / gL - numcor
      ub = EL + sf + (I - (w0 / (1 + i * f))) / gL
      numcor = numcor + 1

      if (numcor > 1000):
        print('Error in numcor')

    Vfix[0] = fsolve(G, (lb + ub) / 2)
    lb = EL + sf + (I - (w0 / (1 + i * f))) / gL
    ub = Vup
    numcor = 0

    while (np.sign(G(ub)) / np.sign(G(lb)) == 1):
      lb = EL + sf + (I - (w0 / (1 + i * f))) / gL - numcor
      ub = Vup
      numcor = numcor + 1
      if (numcor > 1000):
        print('Error')

    Vfix[1] = fsolve(G, (lb + ub) / 2)
  elif w0 == w_ref:
    Vfix = Vth
  else:
    Vfix = []

  return Vfix


def Define_I_ref(I0, Par):
  re = FRsimpAdEx(Par, I0, 0, [], [])
  if type(re) == type(None):
    re = 0
  q = (re - 200) ** 2
  return q


def rand_par(N, par_mean, par_std, par_min, par_max, distr_flag):
  if par_std == 0:
    if par_max == 0:
      par = par_mean * np.ones(N)
    else:
      par = par_min + (par_max - par_min) * np.random.random(size=N)
  else:
    if distr_flag == 0:
      par = par_mean + par_std * np.random.normal(size=N)
      exc_ind = np.where((par < par_min) | (par > par_max))[0]
      par[exc_ind] = par_min + (par_max - par_min) * np.random.random(size=len(exc_ind))
    elif distr_flag == 1:
      par = par_min + (par_max - par_min) * np.random.random(size=N)
    elif distr_flag == 2:
      par = np.exp(np.random.normal(size=N) * par_std + par_mean)
      exc_ind = np.where((par < par_min) | (par > par_max))[0]
      par[exc_ind] = par_min + (par_max - par_min) * np.random.random(size=len(exc_ind))
    else:
      raise ValueError
  return par


def SetCon_CommonNeighbour_Recur(n_pop, p_con, p_self_con):
  slope = 20 * 3.9991 / n_pop

  X = (np.random.random((n_pop, n_pop)) < p_con)
  X_nondiag = X.copy()
  np.fill_diagonal(X_nondiag, False)

  N_neigh = find_neigh_recur(X_nondiag)
  p0 = p_calc_recur(X_nondiag, N_neigh, p_con, p_self_con, slope)

  p = np.zeros((p0.shape[0], 2))
  p[:, 0] = p0[:, 0]
  p[:, 1] = p0[:, 5]

  X_diag = X.copy()
  np.fill_diagonal(X_diag, True)

  k = set(map(tuple, zip(*np.where(X_nondiag))))

  X_recur = np.logical_and(X_nondiag, X_nondiag.transpose())
  X_recur_tril = np.tril(X_recur)
  X_none = np.logical_not(np.logical_or(X_diag, X_diag.transpose()))

  k_recur_tril = set(map(tuple, zip(*np.where(X_recur_tril))))
  k_recur = set(map(tuple, zip(*np.where(X_recur))))
  k_missing = set(map(tuple, zip(*np.where(X_none))))

  pairs_select = []

  for i in range(p.shape[0]):
    pair_id_act = set(map(tuple, zip(*np.where(N_neigh == p[i, 0]))))
    k_missing_act = k_missing.intersection(pair_id_act)
    pairs_id_old = k.intersection(pair_id_act)

    pairs_id_recur_old = k_recur_tril.intersection(pair_id_act)
    pairs_id_recur_old2 = k_recur.intersection(pair_id_act)
    pairs_id_uni_old = pairs_id_old.difference(pairs_id_recur_old2)

    N_rec = (np.floor(p[i, 1] * p_self_con / 2 * len(pair_id_act))).astype(int)
    N_uni = (np.ceil(p[i, 1] * len(pair_id_act)) - 2 * N_rec).astype(int)

    if len(pairs_id_recur_old) >= N_rec:
      k1_old = np.arange(len(pairs_id_recur_old))
      np.random.shuffle(k1_old)
      k1_select = np.asarray(k1_old[:N_rec])

      for cell1, cell2 in np.asarray(list(pairs_id_recur_old))[k1_select]:
        pairs_select.extend([(cell1, cell2), (cell2, cell1)])

    else:
      for cell1, cell2 in list(pairs_id_recur_old):
        pairs_select.extend([(cell1, cell2), (cell2, cell1)])

      N_new = N_rec - len(pairs_id_recur_old)
      missing_pairs_id = list(k_missing_act)
      k1_new = np.arange(len(missing_pairs_id))
      np.random.shuffle(k1_new)
      select = []

      kk = 0
      kkk = 0
      if len(k1_new) > 0 and len(missing_pairs_id) > 0:
        while kk < N_new:
          cell1, cell2 = missing_pairs_id[k1_new[kkk]]
          kkk += 1
          if cell1 > cell2:
            pairs_select.extend([(cell1, cell2), (cell2, cell1)])
            select.extend([(cell1, cell2), (cell2, cell1)])
            kk += 1
        if len(pairs_select):
          _ = np.unique(np.vstack(pairs_select), axis=0, return_counts=True)[1]
        k_missing_act = k_missing_act.difference(set(select))

    if len(pairs_id_uni_old) > N_uni:
      k1_old = np.arange(len(pairs_id_uni_old))
      np.random.shuffle(k1_old)
      k1_select = np.asarray(k1_old[:N_uni])
      pairs_select.extend(np.asarray(list(pairs_id_uni_old))[k1_select])
    else:
      pairs_select.extend(list(pairs_id_uni_old))
      N_new = N_uni - len(pairs_id_uni_old)

      missing_pairs_id = np.asarray(list(k_missing_act))
      k1_new = np.arange((len(missing_pairs_id)))
      np.random.shuffle(k1_new)

      k1_select = np.asarray(k1_new[:N_new])
      pairs_select.extend(missing_pairs_id[k1_select])

  pairs_diag = [(i, i) for i in range(n_pop)]
  pairs_diag_old = list(map(tuple, zip(*np.where(X_diag))))
  N_diag_old = np.sum(X_diag).astype(int)

  if N_diag_old > round(p_self_con * len(X_diag)):
    k1_old = np.arange(N_diag_old)
    np.random.shuffle(k1_old)
    k1_select = k1_old[:int(round(p_self_con * len(X_diag)))]
    pairs_select.extend(np.asarray(pairs_diag_old)[k1_select])
  else:
    N_new = int(round(p_self_con * len(X_diag))) - N_diag_old
    pairs_select.extend(pairs_diag_old)
    missing_pairs_id = set(pairs_diag).difference(set(pairs_diag_old))
    k1_new = np.arange(N_new)
    np.random.shuffle(k1_new)
    pairs_select.extend(np.asarray(np.asarray(list(missing_pairs_id))[k1_new]))

  pairs_select = np.vstack(pairs_select)
  X_out = np.zeros((n_pop, n_pop), dtype=bool)
  X_out[pairs_select[:, 0], pairs_select[:, 1]] = True
  return X_out, np.sum(X_out)


def find_neigh_recur(X):
  Ntarget = X.shape[0]
  Nsource = X.shape[1]

  # X_recur = X_local + X_local.transpose()
  X_recur = np.logical_or(X, X.transpose())

  pairs2 = []
  for i in range(Ntarget):
    sources = np.where(X_recur[i])[0]
    pairs2.extend(list(product(sources, sources)))
  pairs_unique2, pairs_neighs2 = np.unique(np.asarray(pairs2), axis=0, return_counts=True)
  neigh_mat = np.zeros((Ntarget, Nsource))
  neigh_mat[pairs_unique2[:, 0], pairs_unique2[:, 1]] = pairs_neighs2
  np.fill_diagonal(neigh_mat, -1)
  return neigh_mat


def p_calc_recur(X, N_neigh, pCon, pSelfCon, slope):
  Ntarget = X.shape[0]
  X = np.tril(X)

  lt = []
  for i in range(Ntarget):
    for j in range(i):
      lt.append((i, j))

  lt = set(lt)
  pairs_select = set(map(tuple, zip(*np.where(X))))

  N_neigh_intersect = list(lt.intersection(pairs_select))
  N_neigh_ = np.vstack(N_neigh_intersect)
  _, N_neigh_unique = np.unique(N_neigh_, axis=1, return_counts=True)

  N_neigh_selected = N_neigh[N_neigh_[:, 0], N_neigh_[:, 1]]
  p1 = np.unique(N_neigh[N_neigh >= 0])
  p = np.zeros((len(p1), 6))
  p[:, 0] = p1

  for i in range(len(p1)):
    pair_act = np.where(N_neigh == p1[i])
    p[i, 1] = len(pair_act[0])
    p[i, 2] = np.sum((N_neigh_selected == p1[i]).astype(int))
    p[i, 3] = p[i, 2] / p[i, 1]

  off = fmin(lambda N0: p_min(N0, p, pCon, slope), np.max(p[:, 0]))

  N1 = np.floor(min(np.max(p[:, 0]), off + 1 / slope / pCon))
  N0 = max(np.min(p[:, 0]), np.ceil(off))
  ind = np.isin(p[:, 0], np.arange(N0, N1 + 1))
  p[ind, 4] = pCon * slope * (p[ind, 0] - off)
  ind_type = ind.astype(int)

  if len(ind_type) and len(np.where(ind_type)[0]):
    p[np.where(ind_type)[0][-1] + 1:, 4] = 1
  else:
    p[:, 4] = 1

  N_original = X.shape[0] ** 2 * pCon - X.shape[0] * pSelfCon
  N_act = p[:, 1] @ p[:, 4]
  p[:, 5] = p[:, 4] * N_original / N_act

  return p


def p_min(N0, p, pCon, slope):
  N1 = np.round(min(max(p[:, 0]), N0 + 1 / slope / pCon))

  N_2 = p[np.where((p[:, 0] > N0) & (p[:, 0] <= N1)), 0]
  pN_2 = p[np.where((p[:, 0] > N0) & (p[:, 0] <= N1)), 1] / np.sum(p[:, 1])
  pN_3 = p[np.where(p[:, 0] > N1), 1] / np.sum(p[:, 1])

  return abs(np.sum(pN_2 * slope * (N_2 - N0)) + np.sum(pN_3) - 1)


def common_neigh_analysis(X_conn, X_neigh):
  X_neigh_ = X_neigh + 1
  X_id = (X_conn > 0).astype(int) - (X_conn == 0).astype(int)
  X_id = X_neigh_ * X_id - 1

  unique1a, unique1b = np.unique(X_id, return_counts=True)
  unique2a, unique2b = np.unique(X_neigh, return_counts=True)

  valid1 = np.where(unique1a >= 0)[0].astype(int)
  valid2 = np.where(unique2a >= 0)[0].astype(int)

  Nneigh1 = unique1a[valid1].astype(int)
  count1 = unique1b[valid1]

  Nneigh2 = unique2a[valid2].astype(int)
  count2 = unique2b[valid2]

  Nmax = max(np.max(Nneigh1), np.max(Nneigh2))

  Neigharray1 = np.zeros(Nmax + 1)
  Neigharray2 = np.zeros(Nmax + 1)

  Neigharray1[Nneigh1] = count1
  Neigharray2[Nneigh2] = count2

  Neigharray = Neigharray1 / Neigharray2

  return np.arange(Nmax + 1), Neigharray


def reciprocate_analysis(X):
  Ntotal = np.sum((X > 0).astype(int))
  Nrec = np.sum((X > 0).astype(int) * (X.transpose() > 0).astype(int))

  return Nrec / Ntotal


def pCon_analysis(X):
  return np.sum((X > 0).astype(int)) / (X.shape[0] * X.shape[1])
